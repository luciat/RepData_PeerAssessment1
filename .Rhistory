mean(iris$Petal.Width)
mean(iris$Sepal.Width)
mean(iris$Sepal.Length)
data(mtcars)
?mtcars
f1 <- factor(mtcars$cyl)
f1
split(mtcars$mpg, mtcars$cyl)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
mean(mtcars$mpg, mtcars$cyl)
apply(mtcars, 2, mean)
split(mtcars, mtcars$cyl)
lapply(mtcars, mean)
sapply(mtcars, cyl, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
tapply(mtcars$cyl, mtcars$mpg, mean)
with(mtcars, tapply(mpg, cyl, mean))
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
with(mtcars, tapply(mpg, cyl, mean))
apply(mtcars, 2, mean)
apply(mtcars, mean)
lapply(mtcars, mean)
sapply(mtcars, cyl, mean)
head(mtcars)
tapply(mtcars$hp, mtcars$cyl, mean)
hp_cyl <- tapply(mtcars$hp, mtcars$cyl, mean)
class(hp_cyl)
hp_cyl[3] - hp_cyl[0]
hp_cyl$8 - hp_cyl$4
hp_cyl[2,3] - hp_cyl[2,1]
hp_cyl[3] - hp_cyl[1]
debug(ls)
ls
?ls
?debug
exit
quit
trace
undebug(ls)
debug(ls, on=TRUE)
debug(ls)
ls
?ls
ls
debug(ls)
library(datasets)
data(iris)
?iris
spec_Virginica <- iris[iris$Species == "virginica"]
spec_Virginica <- iris[iris$Species == "virginica", ]
spec_Virginica
mean(spec_Virginica$Sepal.Length)
apply(iris, 2, mean)
apply(iris[, 1:4], 2, mean)
mean(iris$Sepal.Length)
mean(iris$Sepal.Width)
mean(iris$Petal.Length)
mean(iris$Petal.Width)
with(mtcars, tapply(mpg, cyl,mean))
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
mean(mtcars, mtcars$mpg == 4)
mean(mtcars[, mtcars$mpg == 4])
mean(mtcars$hp[mtcars$cyl == 4])
mean(mtcars$hp[mtcars$cyl == 8])
mean(mtcars$hp[mtcars$cyl == 8]) - mean(mtcars$hp[mtcars$cyl == 4])
?debug
makeCacheMatrix <- function(x = matrix()) {
inv_x <- NULL
set <- function(y) {
x <<- y
inv_x <<- NULL
}
get <- function() x
setinverse <- function(inverse) inv_x <<- inverse
getinverse <- function() inv_x
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the "special matrix" created with makeCacheMatrix.
## If the inverse has already been calculated and the matrix has not changed, this function
## should retrieve the inverse from the cache.
cacheSolve <- function(sm, x) {
## Get current matrix
cx <- sm$get()
## If the matrix has not changed, retrieve its inverse if already calculated
if (identical(dim(x), dim(cx)) && all(x == cx)) {
ix <- sm$getinverse()
if (!is.null(ix)) {
message("getting cached inverse")
return(ix)
}
}
## Compute inverse
message("computing new inverse")
sm$set(x)
ix <- solve(x)
sm$setinverse(ix)
ix
}
spec_m <- makeCacheMatrix()
spec_m
m <- matrix(c(1,3,4,2,5,6,9,1,7), 3, 3)
m
cacheSolve(spec_m, m)
cacheSolve(spec_m, m)
inv_x <- cacheSolve(spec_m, m)
inv_x
m <- matrix(c(1,3,4,2,3,6,9,1,7), 3, 3)
inv_x <- cacheSolve(spec_m, m)
inv_x
inv_x <- cacheSolve(spec_m, m)
inv_x
f <- gl(40, 10)
f
str(f)
summary(f)
set.seed(1)
rnorm(10)
set.seed(1)
rnorm(10)
set.seed(2)
rnorm(10)
set.seed(1)
rnorm(10)
ppois(2, 2)
ppois(2, 2)
ppois(4, 2)
ppois(6, 2)
ppois(8, 2)
ppois(100, 2)
ppois(1000, 2)
ppois(1, 2)
set.seed(20)
x <- rnorm(100)
e <- rnorm(100, 0, 2)
e
mean(e)
mean(x)
sd(e)
sd(x)
y <- 0.5 + 2 * x + e
y
summary(y)
plot(x, y)
set.seed(10)
x <- rbinom(100, 1, 0.5)
x
e  <- rnorm(100, 0, 2)
e
y <- 0.5 + 2 * x + e
summary(y)
plot(x, y)
v <- rbinom(100, 2, 0.5)
v
v <- rbinom(100, 0, 0.5)
v
v <- rbinom(100, 2, 0.75)
v
n0 <- length(v[] == 0)
n0
n0 <- length(v == 0)
n0
n0 <- length(v == 1)
n0
v[] == 0
sum(v[] == 0)
sum(v[] == 1)
sum(v[] == 2)
set.seed(1)
x <- rnorm(100)
x
log.mu <- 0.5 + 0.3 * x
log.mu
exp(log.mu)
exp(0.31206386)
2^0.31206386
3^0.31206386
2.14^0.31206386
2.14 ^ 0.31206386
2.718 ^ 0.31206386
2.71828 ^ 0.31206386
hilbert <- function(n) {}
hilbert <- function(n) {}
hilbert <- function(n) { 1 <- 1:n  1/ outer(i-1, i , "+")}
hilbert <- function(n) {
1 <- 1:n
1/ outer(i-1, i , "+")
}
x <- hilbert(1000)
hilbert <- function(n) {
i <- 1:n
1/ outer(i-1, i , "+")
}
x <- hilbert(1000)
x
system.time(svd(x))
?svd
system.time({
n <- 1000
r <- numeric(n)
for (i in 1:n) {
x <- rnorm(n)
r[i] <- mean(x)
}
})
set.seed(1)
rpois(5, 2)
library(datasets)
Rprof()
mean(1:10)
summaryRprof()
Rprof(Rprof.out)
Rprof("Rprof.out")
mean(1:10)
summaryRprof()
Rprof.out
Rprof()
ls
ls()
Rprof()
rnorm(100)
ls()
summaryRprof()
Rprof()
n <- 1000
r <- numeric(n)
for (i in 1:n) {
x <- rnorm(n)
r[i] <- mean(x)
}
summaryRprof()
n <- 1000
r <- numeric(n)
for (i in 1:n) {
x <- rnorm(n)
r[i] <- mean(x)
}
Rprof(NULL)
summaryRprof()
Rprof()
fit <- lm(log.mu ~ 2 + 10)
Rprof()
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
Rprof(NULL)
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
Rprof()
lm.D9 <- lm(weight ~ group)
Rprof(NULL)
summaryRprof()
Rprof()
Rprof(NULL)
summaryRprof()
summaryRprof()
ls()
Rprof()
Rprof(NULL)
summaryRprof()
Rprof()
Rprof(NULL)
ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
weight <- c(ctl, trt)
summaryRprof()
Rprof()
fit <- lm(weight ~ group)
Rprof(NULL)
summaryRprof()
Rprof()
Rprof(NULL)
summaryRprof()
Rprof()
lm.D90 <- lm(weight ~ group - 1)
Rprof(NULL)
summaryRprof()
set.seed(1)
rpois(5,2)
swirl()
library(swirl)
swirl()
ls()
class(plants)
dim(plants)
nrow(plants)
ncol(plants)
object.size(plants)
names(plants)
head(palnts)
head(plants)
head(plants, 10)
tail(plants, 15)
summary(plants)
table(plants$Active_Growth_Period)
str(plants)
?sample
sample(1:6, 4, replace = TRUE)
sample(1:6, 4, replace = TRUE)
sample(1:20, 10)
LETTERS
sample(LETTERS)
flips <- sample(c(0, 1), 100, replace = TRUE, prob = c(0.3, 0.7))
flips
sum(flips)
?rbinom
rbinom(1, size = 100, prob = 0.7)
flips2 <- rbinom(1, size = 100, prob = 0.7)
flips2 <- rbinom(100, size = 1, prob = 0.7)
flips2
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, mean = 100, sd = 25)
rpois(5, 10)
replicate(100, rpois(5, 10))
my_pois <- replicate(100, rpois(5, 10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
data("cars")
data(cars)
?cars
head(cars)
plot(cars)
?plot
plot(x = cars$speed, y = cars$dist)
plot(x = cars$dist, y = cars$speed)
plot(x = cars$speed, y = cars$dist, xlab = "Speed")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, ylab = "Stopping Distance")
plot(x = cars$speed, y = cars$dist, xlab = "Speed", ylab = "Stopping Distance")
plot(cars, main = "My Plot")
plot(cars, sub = "My Plot Subtitle")
plot(cars, col = 2)
plot(cars, xlim = c(10, 15))
plot(cars, pch = 2)
data("mtcars")
data(mtcars)
play()
dim(mtcars)
head(mtcars)
tail(mtcars)
names(mtcars)
nxt()
?boxplot
boxplot(mpg ~cyl, data = mtcars)
hist(mtcars$mpg)
library(datasets)
with(airquality, plot(Wind, Ozone))
title(main = "Ozone and Wind in New York City")
with(airquality, plot(Wind, Ozone), main = "Ozone and Wind in New York City" )
with(airquality, plot(Wind, Ozone, main = "Ozone and Wind in New York City"))
with(subset(airquality, Month == 5), points(Wind, Ozone, col = "blue"))
with(subset(airquality, Month != 5), points(Wind, Ozone, col = "red"))
legend("topright", pch = 1, col = c("blue", "red"), legend = c("May", "Other Months"))
with(airquality, plot(Wind, Ozone, main = "Ozone and Wind in New York City"), type = "n")
library(swirl)
swirl()
dim(p0)
dim(pm0)
head(pm0)
cnames
cnames <- strsplit(cnames, "|", fixed = TRUE)
cnames
names(pm0) <- cnames[[1]][wcol]
names(pm0) <- make.names(cnames[[1]][wcol])
head(pm0)
x0 <- pm0$Sample.Value
str(c0)
str(x0)
mean(is.na(x0))
names(pm1) <- make.names(cnames[[1]][wcol])
dim(pm1)
x1 <- pm1$Sample.Value
mean(is.na(x1))
summary(x0)
summary(x1)
boxplot(x0, x1)
boxplot(log10(x0),log10(x1))
negative <- x1 < 0
sum(negative, na.rm = TRUE)
mean(negative, na.rm = TRUE)
dates <- pm1$Date
str(dates)
dates <- as.Date(as.character(dates), "%Y%m%d")
head(dates)
hist(dates[negative], "month")
str(site0)
both <- intersect(site0, site1)
coth
both
head(pm0)
cnt0 <- subset(pm0, State.Code == 36 & county.site %in% both)
cnt1 <- subset(pm1, State.Code == 36 & county.site %in% both)
sapply(split(cnt0, cnt0$county.site), nrow)
sapply(split(cnt1, cnt1$county.site), nrow)
pm0sub <- subset(cnt0, County.Code == 63 & Site.ID == 2008)
pm1sub <- subset(cnt1, County.Code == 63 & Site.ID == 2008)
x0sub <- pm0sub$Sample.Value
x1sub <- pm1sub$Sample.Value
dates0 <- as.Date(as.character(pm0sub$Date), "%Y%m%d")
dates1 <- as.Date(as.character(pm1sub$Date), "%Y%m%d")
par(mfrow = c(1, 2), mar = c(4, 4, 2, 1))
plot(dates0, x0sub, pch = 20)
abline(h = median(x0sub, na.rm = TRUE), lwd = 2)
plot(dates1, x1sub, pch = 20)
abline(h = median(x1sub, na.rm = TRUE), lwd = 2)
rng <- range(x0sub, x1sub, na.rm = TRUE)
rng
mn0 <- with(pm0, tapply(Sample.Value, State.Code, mean, na.rm = TRUE))
str(mn0)
mn1 <- with(pm1, tapply(Sample.Value, State.Code, mean, na.rm = TRUE))
str(mn1)
summary(mn0)
summary(mn1)
d0 <- data.frame(state = names(mn0), mean = mn0)
d1 <- data.frame(state = names(mn1), mean = mn1)
mrg <- merge(d0, d1, by = "state")
dim(mrg)
head(mrg)
with(mrg, plot(rep(1, 52), mrg[, 2], xlim = c(.5, 2.5)))
with(mrg, points(rep(1, 52), mrg[, 3]))
with(mrg, points(rep(2, 52), mrg[, 3]))
segments(rep(1, 52), mrg[, 2], rep(2, 52), mrg[, 3])
mrg[mrg$mean.x < mrg$mean.y, ]
pm0
library(kernlab)
install.packages("kernlab")
library(kernlab)
data("spam")
set.seed(3435)
trainIndicator <- rbinom(4601, size = 1, prob = 0.5)
table(trainIndicator)
class(spam)
dim(spam)
trainSpam <- spam[trainIndicator = =1, ]
testSpam <- spam[trainIndicator == 0, ]
trainSpam <- spam[trainIndicator == 1, ]
testSpam <- spam[trainIndicator == 0, ]
dim(trainSpam)
dim(testSpam)
names(trainSpam)
head(trainSpam)
table(trainSpam$type)
plot(trainSpam$capitalAve ~ trainSpam$type)
plot(log10(trainSpam$capitalAve + 1) ~ trainSpam$type)
plot(log10(trainSpam[, 1:4] + 1))
hCluster <- hclust((dist(t(trainSpam[, 1:57]))))
plot(hCluster)
hClusterUpdated <- hclust(dist(t(log10(trainSpam[, 1:55] + 1)))
)
plot(hClusterUpdated)
# Statistical prediction / modeling
trainSpam$numType <- as.numeric(trainSpam$type) - 1
head(train)
lmFormula <- reformulate(names(trainSpam)[5], response ="numType")
lmFormula
costFunction <- function(x, y), sum(x != (y > 0.5))
cvError <- rep(NA, 55)
library(boot)
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType")
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)
cvError[i] <- cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
costFunction <- function(x, y) sum(x != (y > 0.5))
cvError <- rep(NA, 55)
library(boot)
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType")
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)
cvError[i] <- cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
warnings()
costFunction <- function(x, y) sum(x != (y > 0.5))
cvError <- rep(NA, 55)
library(boot)
for (i in 1:55) {
lmFormula <- reformulate(names(trainSpam)[i], response = "numType")
glmFit <- glm(lmFormula, family = "binomial", data = trainSpam)
cvError[i] <- cv.glm(trainSpam, glmFit, costFunction, 2)$delta[2]
}
head(cvError)
length(cvError)
names(trainSpam)[which.min(cvError)]
class(testSpam)
dim(testSpam)
dim(testSpam)[1]
predictionModel <- glm(numType ~ charDollar, family = "binomial", data = trainSpam)
predictionModel
predicitionTest <- predict(predictionModel, testSpam)
class(predicitionTest)
length(predicitionTest)
predictedSpam <- rep("nonspam", dim(testSpam)[1])
length(predicitionSpam)
length(predicitedSpam)
length(predictedSpam)
head(predictionModel$fitted)
predictedSpam[predictionModel$fitted > 0.5] <- "spam"
length(predictedSpam)
head(predictedSpam)
table(predictedSpam, testSpam$type)
(61 + 458)/ (1346 + 458 +61 + 449)
*This txt will appear italicized*
install.packages("xtable")
library("knitr", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
setwd("~/DataScience_Coursera/ReproducibleResearch/Week2/CourseProject1/RepData_PeerAssessment1")
